var browserify = require('browserify');
var gulp = require('gulp');
var source = require('vinyl-source-stream');
var buffer = require('vinyl-buffer');
var uglify = require('gulp-uglify');
var sourcemaps = require('gulp-sourcemaps');
var gutil = require('gulp-util');
var folderify = require('folderify');
var config = require('../config');
var handleErrors = require('../util/handle-errors');
var replace = require('gulp-replace');
var fs = require('fs');
// use comment json to parse vanilla json
var json = require('comment-json');
var ba = require('../util/build-argv');
var gulpif = require('gulp-if');
var eslint = require('gulp-eslint');
var git = require('gulp-git');
var babelify = require('babelify');


gulp.task('browserify', ['eslint'], function () {

    // set up the browserify instance on a task basis
    var b = browserify({
        entries: config.src + '/scripts/app.js',
        debug: true,
        transform: [
            // 只对es后缀文件做转换
            babelify.configure({
                // ignore: /.*\/(lib|libs)\/.*.js/,
                only: /.*\.es|.*app\.js/,
                presets: ["es2015", "stage-3"],
                plugins: ["transform-async-to-generator"]
            }),
            folderify
        ]
    });

    return b.bundle()
        .pipe(source('bundle.js'))
        .pipe(buffer())
        .pipe(gulpif(ba.isSourceMapping, sourcemaps.init({
            loadMaps: true
        })))
        // Add transformation tasks to the pipeline here.
        .pipe(replace(/{{(.+Api)}}/g, function (match, apiName) {
            // TODO 多次读文件效率低
            var apiConfigStr = fs.readFileSync('./assets/api.json').toString();
            var apiConfig = json.parse(apiConfigStr, null, true);
            if (!apiConfig[apiName]) {
                handleErrors(new Error('Api replace error, apiName: "' + apiName + '", check your code and api.json'));
                return '';
            }
            // apiMock 优先级高于环境选择
            var apiType = ba.isApiMock ? ba.TASK_TYPES.TASK_SERVE : ba.currentMode;
            return apiConfig[apiName][apiType];
        }))
        .pipe(gulpif(!ba.isServe, uglify()))
        .on('error', gutil.log)
        .pipe(gulpif(ba.isSourceMapping, sourcemaps.write('./')))
        .pipe(gulp.dest(config.dest + '/scripts'));
});;

gulp.task('eslint:commit', function () {
    var diffList = [];
    if (ba.withoutEslint) {
        return;
    }
    git.exec({
        args: 'diff-index HEAD --name-only --diff-filter ACMR | egrep ".*/scripts/.*\.(js|es)"'
    }, function (err, stdout) {
        // if (err instanceof Error) {
        //     throw err;
        // }
        diffList = stdout.trim().split('\n');
        // build测试时git目录与gulp根目录不一致 做替换
        diffList = diffList.map(function (path) {
            return path.replace(/^[\w\W]*app\//, './app/');
        });
        return gulp.src(diffList)
            .pipe(eslint(__dirname + '/../eslintrc.config.js'))
            .pipe(eslint.format())
            .pipe(eslint.failAfterError())
            .on('error', error => {
                console.log('代码风格有错误 请于提交前修改');
                process.exit(1);
            });;
    });

});

gulp.task('eslint', function () {
    var diffList = [];
    if (ba.withoutEslint) {
        return;
    }
    git.exec({
        args: "diff-index HEAD --name-only --diff-filter ACMR | egrep '.*/scripts/.*\.(js|es)'"
    }, function (err, stdout) {
        // if (err instanceof Error) {
        //     throw err;
        // }
        if (stdout.trim()) {
            diffList = stdout.trim().split('\n');
            // build测试时git目录与gulp根目录不一致 做替换
            diffList = diffList.map(function (path) {
                return path.replace(/^[\w\W]*app\//, './app/');
            });
            return gulp.src(diffList)
                .pipe(eslint(__dirname + '/../eslintrc.config.js'))
                .pipe(eslint.format())
                .pipe(eslint.failAfterError())
                .on('error', error => {
                    console.log('代码风格有错误 请于提交前修改');
                });;
        }

    });

});
